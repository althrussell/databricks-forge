/**
 * Notebook deployment -- generates SQL notebooks and deploys them
 * to the Databricks workspace via the Workspace REST API.
 *
 * Each use case gets its own notebook containing:
 * - Documentation header (name, domain, statement, solution, value)
 * - SQL code (if generated) or a scaffold template with table references
 * - Score summary
 *
 * Notebooks are organised by domain in the workspace.
 */

import { importNotebook, mkdirs } from "@/lib/dbx/workspace";
import type { PipelineRun, UseCase } from "@/lib/domain/types";
import { groupByDomain } from "@/lib/domain/scoring";

interface NotebookDeployResult {
  count: number;
  path: string;
  notebooks: Array<{
    name: string;
    path: string;
  }>;
  skipped: number;
}

/**
 * Generate and deploy SQL notebooks for each use case.
 * Organised by domain in the workspace.
 */
export async function generateNotebooks(
  run: PipelineRun,
  useCases: UseCase[]
): Promise<NotebookDeployResult> {
  const bizSlug = run.config.businessName.replace(/\s+/g, "_");
  const basePath = run.config.generationPath.replace(
    /^\.?\/?/,
    `/Workspace/inspire_gen/${bizSlug}/`
  );

  // Create base directory
  await mkdirs(basePath);

  // Deploy an index notebook at root
  const indexContent = generateIndexNotebook(run, useCases);
  try {
    await importNotebook({
      path: `${basePath}_Index`,
      language: "SQL",
      content: indexContent,
      overwrite: true,
    });
  } catch (error) {
    console.warn("[notebooks] Failed to deploy index notebook:", error);
  }

  const grouped = groupByDomain(useCases);
  const deployed: Array<{ name: string; path: string }> = [];
  let skipped = 0;

  for (const [domain, cases] of Object.entries(grouped)) {
    const domainSlug = domain.replace(/[^a-zA-Z0-9]/g, "_");
    const domainPath = `${basePath}${domainSlug}`;
    await mkdirs(domainPath);

    for (const uc of cases) {
      const notebookName = `UC${String(uc.useCaseNo).padStart(3, "0")}_${uc.name.replace(/[^a-zA-Z0-9]/g, "_").substring(0, 50)}`;
      const notebookPath = `${domainPath}/${notebookName}`;

      const content = generateUseCaseNotebook(run, uc);

      try {
        await importNotebook({
          path: notebookPath,
          language: "SQL",
          content,
          overwrite: true,
        });
        deployed.push({ name: notebookName, path: notebookPath });
      } catch (error) {
        console.warn(
          `[notebooks] Failed to deploy ${notebookName}:`,
          error
        );
        skipped++;
      }
    }
  }

  return {
    count: deployed.length,
    path: basePath,
    notebooks: deployed,
    skipped,
  };
}

// ---------------------------------------------------------------------------
// Index notebook
// ---------------------------------------------------------------------------

function generateIndexNotebook(
  run: PipelineRun,
  useCases: UseCase[]
): string {
  const domains = [...new Set(useCases.map((uc) => uc.domain))].sort();
  const aiCount = useCases.filter((uc) => uc.type === "AI").length;
  const statsCount = useCases.length - aiCount;
  const avgScore = useCases.length
    ? Math.round(
        (useCases.reduce((s, uc) => s + uc.overallScore, 0) /
          useCases.length) *
          100
      )
    : 0;

  const domainList = domains
    .map((d) => {
      const count = useCases.filter((uc) => uc.domain === d).length;
      return `-- MAGIC | ${d} | ${count} |`;
    })
    .join("\n");

  return `-- Databricks notebook source
-- MAGIC %md
-- MAGIC # Databricks Inspire AI — Use Case Catalog
-- MAGIC
-- MAGIC **Business:** ${run.config.businessName}
-- MAGIC
-- MAGIC **Generated:** ${new Date().toISOString().split("T")[0]}
-- MAGIC
-- MAGIC ---
-- MAGIC
-- MAGIC ## Summary
-- MAGIC
-- MAGIC | Metric | Value |
-- MAGIC |--------|-------|
-- MAGIC | Total Use Cases | ${useCases.length} |
-- MAGIC | AI Use Cases | ${aiCount} |
-- MAGIC | Statistical Use Cases | ${statsCount} |
-- MAGIC | Business Domains | ${domains.length} |
-- MAGIC | Average Score | ${avgScore}% |
-- MAGIC
-- MAGIC ## Domains
-- MAGIC
-- MAGIC | Domain | Use Cases |
-- MAGIC |--------|-----------|
${domainList}
-- MAGIC
-- MAGIC ## Business Priorities
-- MAGIC
-- MAGIC ${run.config.businessPriorities.map((p) => `- ${p}`).join("\n-- MAGIC ")}
-- MAGIC
-- MAGIC ---
-- MAGIC
-- MAGIC > Each domain folder contains individual SQL notebooks for every use case.
-- MAGIC > Notebooks with generated SQL are ready to run. Scaffold notebooks contain
-- MAGIC > table references and a template to help you build the query.
-- MAGIC
-- MAGIC *Generated by Databricks Inspire AI*
`;
}

// ---------------------------------------------------------------------------
// Per-use-case notebook
// ---------------------------------------------------------------------------

function generateUseCaseNotebook(
  run: PipelineRun,
  uc: UseCase
): string {
  const header = `-- Databricks notebook source
-- MAGIC %md
-- MAGIC # ${uc.useCaseNo}. ${uc.name}
-- MAGIC
-- MAGIC **Domain:** ${uc.domain} / ${uc.subdomain}
-- MAGIC
-- MAGIC **Type:** ${uc.type} | **Technique:** ${uc.analyticsTechnique}
-- MAGIC
-- MAGIC ---
-- MAGIC
-- MAGIC ## Business Statement
-- MAGIC
-- MAGIC ${wrapMagic(uc.statement)}
-- MAGIC
-- MAGIC ## Solution
-- MAGIC
-- MAGIC ${wrapMagic(uc.solution)}
-- MAGIC
-- MAGIC ## Business Value
-- MAGIC
-- MAGIC ${wrapMagic(uc.businessValue)}
-- MAGIC
-- MAGIC ---
-- MAGIC
-- MAGIC **Beneficiary:** ${uc.beneficiary} | **Sponsor:** ${uc.sponsor}
-- MAGIC
-- MAGIC **Score:** ${Math.round(uc.overallScore * 100)}% (Priority: ${Math.round(uc.priorityScore * 100)}%, Feasibility: ${Math.round(uc.feasibilityScore * 100)}%, Impact: ${Math.round(uc.impactScore * 100)}%)
-- MAGIC
-- MAGIC **Tables:** ${uc.tablesInvolved.join(", ") || "N/A"}
-- MAGIC
-- MAGIC ---

-- COMMAND ----------
`;

  if (uc.sqlCode) {
    // Use case has generated SQL
    return `${header}
-- Generated by Databricks Inspire AI for ${run.config.businessName}
-- Tables: ${uc.tablesInvolved.join(", ")}

${uc.sqlCode}
`;
  }

  // No SQL yet — generate a scaffold template
  return `${header}
-- ============================================================================
-- SQL Scaffold for: ${uc.name}
-- Generated by Databricks Inspire AI for ${run.config.businessName}
-- ============================================================================
--
-- This notebook contains a scaffold SQL template based on the use case
-- definition. Modify and extend the query to implement the full solution.
--
-- Tables referenced by this use case:
${uc.tablesInvolved.map((t) => `--   • ${t}`).join("\n") || "--   (no specific tables identified)"}
-- ============================================================================

-- COMMAND ----------

-- Step 1: Explore the source tables
${generateExploreQueries(uc.tablesInvolved)}

-- COMMAND ----------

-- Step 2: Base data selection (start building your analysis here)
${generateScaffoldSQL(run, uc)}
`;
}

// ---------------------------------------------------------------------------
// Scaffold SQL generation
// ---------------------------------------------------------------------------

/** Generate DESCRIBE + SELECT previews for each table */
function generateExploreQueries(tables: string[]): string {
  if (tables.length === 0) {
    return "-- No specific tables identified. Add your source tables below.\n-- DESCRIBE your_catalog.your_schema.your_table;";
  }

  return tables
    .map(
      (t) => `-- Preview: ${t}
-- DESCRIBE TABLE ${t};
-- SELECT * FROM ${t} LIMIT 10;`
    )
    .join("\n\n");
}

/** Generate a scaffold CTE-based SQL template */
function generateScaffoldSQL(run: PipelineRun, uc: UseCase): string {
  const tables = uc.tablesInvolved;
  const modelEndpoint = run.config.aiModel;

  if (tables.length === 0) {
    return `-- TODO: Add your source tables and build the analysis query
-- WITH base_data AS (
--   SELECT DISTINCT *
--   FROM your_catalog.your_schema.your_table
--   LIMIT 100
-- )
-- SELECT * FROM base_data;`;
  }

  const primaryTable = tables[0];
  const additionalJoins = tables
    .slice(1)
    .map(
      (t, i) =>
        `--   LEFT JOIN ${t} t${i + 2}\n--     ON t1.id = t${i + 2}.id  -- TODO: Set correct join keys`
    )
    .join("\n");

  const joinSection =
    additionalJoins.length > 0
      ? `\n${additionalJoins}`
      : "";

  const aiSection =
    uc.type === "AI"
      ? `
-- Step 3: AI enrichment (${uc.analyticsTechnique})
-- ai_enriched AS (
--   SELECT
--     *,
--     ai_query(
--       '${modelEndpoint}',
--       CONCAT(
--         'You are a ${uc.subdomain} specialist for ${run.config.businessName}. ',
--         'Analyze the following data and provide insights: ',
--         -- TODO: Build your prompt using column values
--         ''
--       ),
--       modelParameters => named_struct('temperature', 0.4)
--     ) AS ai_insights
--   FROM base_data
-- ),

`
      : "";

  return `WITH base_data AS (
  SELECT DISTINCT
    *
    -- TODO: Select specific columns relevant to: ${uc.name}
  FROM ${primaryTable} t1${joinSection}
  -- WHERE 1=1
  --   AND ... -- TODO: Add business-relevant filters
  LIMIT 100
)

${aiSection}-- Final output
SELECT * FROM base_data;

-- TODO: Implement the full analysis for:
-- "${uc.statement}"
--
-- Solution approach:
-- "${uc.solution}"`;
}

// ---------------------------------------------------------------------------
// Text helpers
// ---------------------------------------------------------------------------

/** Wrap long text for MAGIC markdown (handle line breaks) */
function wrapMagic(text: string): string {
  if (!text) return "N/A";
  return text.replace(/\n/g, "\n-- MAGIC ");
}
